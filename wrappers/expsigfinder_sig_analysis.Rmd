---
title: "ExpSigFinder signature analysis"
author: "Ellie Dunstone"
date: "2023-01-31"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/ed4/Documents/phd/chemo_project/BotSeq/WP4/KCL_organoid_work/wp4_2530_20230127/extractions/wp4_2530_20230404_expsigfinder_SBS96_fixed/")
```

```{r load packages}
library(tidyverse)
library(pheatmap)
library(NatParksPalettes)
library(ggbiplot)
library(M3C)
```

## Introduction

This script is for the downstream analysis of putative signatures output by ExpSigFinder (see expsigfinder_wrapper.Rmd). 

## Read in signature table

```{r read in sigs}
all_sigs <- read.table("/Users/ed4/Documents/phd/chemo_project/BotSeq/WP4/KCL_organoid_work/wp4_2530_20230127/extractions/wp4_2530_20230404_expsigfinder_SBS96_fixed/expsigfinder_bg_removed_all_sigs_SBS96.csv", sep = ",", header = TRUE, row.names = 1)
```

## Read in metadata

```{r read metadata}
metadata <- read.table("/Users/ed4/Documents/phd/chemo_project/Metadata/WP4/wp4_sample_subsetting.csv", sep=",", header = TRUE)
```

```{r replace sample names if needed}

for (i in 1:ncol(all_sigs)) {
  colnames(all_sigs)[i] <- metadata$sample_name[metadata$sample == colnames(all_sigs)[i]]
}
```


# Define function for calculating cosine similarity

This section defines a function to calculate the cosine similarity between the spectra/signatures in your test and reference sets. In this script, the putative signatures will be compared against each other first to assess similarity between signatures of the same treatment in different organoid lines, and different treatments that generate similar signatures.

Note: i will also add code to look at the background signatures, but these are currently not included in the output sig table.

```{r cosine similarity function}
#Function for cosine similarity calculation
cos_sim = function(x, y) {res = x %*% y / (sqrt(x %*% x) * sqrt(y %*% y))
res = as.numeric(res)
return(res)}

comparesignatures_cossim <- function(signatures1,signatures2){
  signcompared=matrix(nrow=length(signatures1[1,]),ncol=length(signatures2[1,]))
  for (i in 1:length(signatures1[1,])){
    for (j in 1:length(signatures2[1,])){    
      signcompared[i,j]=cos_sim(signatures1[,i],signatures2[,j])
    }}    
  return(signcompared)
}
```

## Calculate cosine similarities and generate output file

First, set your test and reference signatures. Here, these are the same (the file of all signatures).

```{r set inputs}
test_signatures <- all_sigs[order(row.names(all_sigs)),]
test_signatures <- as.matrix(test_signatures)

reference_signatures <- test_signatures
```

We can now use this function to calculate cosine similarities between the test and reference set, and generate an output file with the results.

```{r cossim output}
#Calculate cosine similarities
csmap = comparesignatures_cossim(reference_signatures, test_signatures)

#Write out your output as table
rownames(csmap) = colnames(reference_signatures)
colnames(csmap) = colnames(test_signatures)
write.csv(csmap, file = "/Users/ed4/Documents/phd/chemo_project/BotSeq/WP4/KCL_organoid_work/wp4_2530_20230127/extractions/wp4_2530_20230404_expsigfinder_SBS96_fixed/20230404_expsigfinder_cossim_all_v_all.csv", row.names = TRUE)
```

## Subset results data for plotting (optional)

If you want to plot only a subset of the data, then you can edit this section to remove the rows/columns corresponding to the samples you don't want to include in the plot. If you do this, you need to change the plotting command to plot the new table ```csmap_subset```.

```{r subset results}
#Subset for plotting if needed
csmap_subset <- csmap[c(1,2,4:12,14),c(1,2,4:12,14)]
```

## Plot results as a heatmap

We can now plot these results as a heatmap. There are lots of options for how to show the data, with details available in the [pheatmap documentation](https://www.rdocumentation.org/packages/pheatmap/versions/1.0.12/topics/pheatmap).

```{r heatmap}
pheatmap(csmap, color=natparks.pals("Acadia",type="continuous",n=40),border_color="NA",cellwidth = 4, cellheight = 4, angle_col = 45,cluster_rows=TRUE,cluster_cols=TRUE, show_rownames = T, show_colnames = T, fontsize = 4)
```

## Plot distribution of cosine similarities

Plot the distribution of cosine similarities between the signatures to attempt to identify a sensible cut off for merging them.

```{r cosine similarity dist plot}
cossims <- unique(unlist(as.list(csmap))) #removing duplicates so each point not included twice, and to remove all but one self-comparison. This could be improved. See below for a better method - rework this.

hist(cossims, breaks = "Scott")

cossims_df <- as.data.frame(cossims)
ggplot(cossims_df, aes(x="cosine similarities", y=cossims)) +
  geom_violin()
```

We can now filter the comparisons in order to look at which signatures are similar. First, format the table:

```{r format cossim df}

#reformat the table
csmap_tidy <- as.data.frame(cbind(sig1 = rownames(csmap), csmap))
rownames(csmap_tidy) <- NULL

csmap_tidy <- pivot_longer(csmap_tidy, cols=c(2:length(csmap_tidy)), names_to = "sig2", values_to = "cossim")

#filter to remove self-comparisons
csmap_tidy <- filter(csmap_tidy, sig1 != sig2)

#filter to remove duplicates 
# entries <- list()
# include <- c()
# 
# for (i in 1:nrow(csmap_tidy)){
#   if (sort(c(csmap_tidy$sig1[i], csmap_tidy$sig2[i], csmap_tidy$cossim[i])) %in% entries) {
#     include <- c(include, FALSE)
#   } else {
#     include <- c(include, TRUE)
#   }
#   entries[[i]] <- sort(c(csmap_tidy$sig1[i], csmap_tidy$sig2[i], csmap_tidy$cossim[i]))
# }


#dumb method but quicker
csmap_tidy_sorted <- csmap_tidy[rev(order(csmap_tidy$cossim)),] #sort table
csmap_tidy_sorted_unique <- csmap_tidy_sorted[seq(1, nrow(csmap_tidy_sorted)-1, 2), ] #remove every other row
length(csmap_tidy_sorted_unique$cossim) == length(unique(csmap_tidy_sorted_unique$cossim)) #check that only unique rows (ID'd using unique cossim values) remain - this may give false negative (FALSE) result if you have two different entries with identical cossim values

cossim_table <- csmap_tidy_sorted_unique
```

Now we can filter these to look at which signatures are similar:

```{r filter sig pairs by cossim}
cossim_table_0.8 <- filter(cossim_table, cossim > 0.8)
hist(as.numeric(cossim_table_0.8$cossim))
cossim_table_0.9 <- filter(cossim_table, cossim > 0.9)
```


Attempting hierarchical clustering:

```{r cossim dist hclust}
csmap_dist <- dist(1-csmap) #make dist object using cs distance (1 - cs sim)

clust_csmap_dist <- hclust(csmap_dist)

plot(clust_csmap_dist, hang = -1, cex = 0.4)

# Convert hclust into a dendrogram and plot
dend_csmap_dist <- as.dendrogram(clust_csmap_dist)
# plot
nodePar <- list(lab.cex = 0.4, pch = c(NA, 19), 
                cex = 0.1, col = "blue")
plot(dend_csmap_dist, type = "rectangle", xlab = "Height",  cex=0.4, horiz=TRUE, nodePar=nodePar)

#using APE package
library(ape)

big_colour = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

treatment_group = gsub("_[^ ]*", "", clust_csmap_dist$labels)
# check the TYPE numbers are correct
big_colour_palette <- sample(big_colour, length(unique(treatment_group)))
col_assignment = big_colour_palette[1:length(unique(treatment_group))]
names(col_assignment) = unique(treatment_group)
cols = col_assignment[treatment_group]
# then pass COLS into your plot

plot(as.phylo(clust_csmap_dist), type = "fan", cex=0.5, label.offset = 0.1, tip.color = cols)

```


## Plot results as a PCA

Here I am trialing PCA to cluster the signatures. 

```{r PCA}

#Add organoid line and treatment metadata
t_all_sigs <- t(all_sigs)
t_all_sigs_df <- as.data.frame(t_all_sigs)
t_all_sigs_df <- mutate(t_all_sigs_df, sample_name = row.names(t_all_sigs_df))
t_all_sigs_metadata <- left_join(t_all_sigs_df, metadata)
  
#mutate(sig_name = rownames(t_all_sigs)) %>% mutate(treatment = str_split_i(sig_name, "_", 1)) %>% mutate(org_line = str_split_i(sig_name, "_", 2))

all_sigs.pca <- prcomp(t_all_sigs, center = TRUE, scale. = TRUE)
summary(all_sigs.pca)

ggbiplot(all_sigs.pca, var.axes = FALSE, groups = t_all_sigs_metadata$treatment) +
  theme_classic()

```

## Plot results as a tSNE

Here I am trialing tSNE to cluster the signatures. 

```{r tSNE}
tsne(all_sigs, labels=t_all_sigs_metadata$treatment, text=t_all_sigs_metadata$treatment,
textlabelsize = 2, perplex = 10)
```

## Plot results as a UMAP

Here I am trialing UMAP to cluster the signatures. 

```{r UMAP}
umap(all_sigs, labels=t_all_sigs_metadata$treatment, text=t_all_sigs_metadata$treatment,
textlabelsize = 2)
```

## Refining signature list

We now want to see whether some of the putative signatures identified in the samples represent the same underlying signature. 

### Samples treated with the same agent

First, we want to check for similarities between samples treated with the same agents. We can subset our list of all signatures by treatment.

```{r subset sigs by treatment}
#ID all treatments
treatment_list <- unique(t_all_sigs_metadata$treatment)

for (t in treatment_list) {
  treatment_samples <- t_all_sigs_metadata$sample_name[t_all_sigs_metadata$treatment == t]
  print(treatment_samples)
  assign(paste0(t, "_all_sigs"), all_sigs[, colnames(all_sigs) %in% treatment_samples])
}
```

```{r init final sig matrix}
final_sigs <- as.data.frame(matrix(nrow = nrow(all_sigs)))
final_sigs[,1] <- row.names(all_sigs)
colnames(final_sigs)[1] <- "MutationType"
```


First, if there is only one signature for an agent, assign this to to the final list as the signature for this agent, and drop from the treatment list.


```{r add single-sample agents}

for (t in treatment_list) {
  treatment_samples <- t_all_sigs_metadata$sample_name[t_all_sigs_metadata$treatment == t]
  if (length(treatment_samples) == 1) {
    sig <- all_sigs[, colnames(all_sigs) == treatment_samples]
    print(treatment_samples)
    final_sigs <- cbind(final_sigs, sig)
    colnames(final_sigs)[ncol(final_sigs)] <- paste0(t, "_sig")
    treatment_list <- treatment_list[-which(treatment_list == t)]
  }
}

print(treatment_list)
```


We want to define a function that we can use to merge putative signatures if we decide they represent the same underlying signature. To do this, we want to weight the signatures according to the actual count data they represent.

We will need the burdens table to calculate the appropriate weightings:

```{r read burdens and merge metadata}
burdens <- read_table("/Users/ed4/Documents/phd/chemo_project/BotSeq/WP4/KCL_organoid_work/wp4_2530_20230127/data/results.mut_burden_all.tsv")
burdens_metadata <- left_join(burdens, select(metadata, sample, sample_name))
```


```{r define sig merge function}
#input a vector of names of 2 or more signatures and the dataframe they are present in. Also, a vector of weightings optionally, which will default to even weighting if not provided.

sigMerge <- function(sig_names, input_df, weightings = rep(1 / length(sig_names), length(sig_names))) {
  
  print(weightings)
  
  # select the columns with the desired signatures from the input data frame
  df4merge <- input_df[, sig_names]
  
  # multiply by the weightings
  for (i in 1:length(sig_names)) {
    df4merge[,i] <- df4merge[,i] * weightings[i]
  }
  
  # calculate sums to give weighted averages
  df4merge <- mutate(df4merge, av_sig = rowSums(df4merge))
  
  print(df4merge)
  
  # return the output
  return(df4merge$av_sig)
}

# debugging
# test_output <- sigMerge(c("MX_sig", "Chlorambucil_sig"), final_sigs)
# test_output2 <- sigMerge(c("MX_sig", "Chlorambucil_sig"), final_sigs, c(0.01,0.99))
# check <- cbind(test_output2, final_sigs$Chlorambucil_sig)
```

We can also define a signature to calculate the appropriate weights for a given list of samples to be merged:
NOTE: this isn't quite right .. It shouldn't just be coverage, it should be proportional to the number of excess mutations. this needs more work

```{r define weight calc function}
#input a list of signature names and output the relative weights according to duplex coverage taken from the burdens_metadata table

getWeights <- function(sig_names) {
  wts <- as.data.frame(cbind(sample_name = sig_names))
  wts <- left_join(wts, select(burdens_metadata, sample_name, total))
  wts <- mutate(wts, wt = total / sum(wts$total))
  return(wts$wt)
}

#test
getWeights(c("D88-BLEO-10", "D88-BLEO-20"))
```


Now we can look at which samples we have for each treatment remaining:

```{r inspect}
for (t in treatment_list) {
  treatment_samples <- t_all_sigs_metadata$sample_name[t_all_sigs_metadata$treatment == t]
  print(treatment_samples)
}
```

For a given treatment, we can look at the cosine similarity results for the relevant samples:

```{r select treatment}
tre <- "Bendamustine"
```

```{r subset csmap treatment}
tre_samples <- t_all_sigs_metadata$sample_name[t_all_sigs_metadata$treatment == tre]
csmap_subset <- csmap[tre_samples, tre_samples]
```

```{r heatmap csmap treatment subset}
pheatmap(csmap_subset, color=natparks.pals("Acadia",type="continuous",n=40),border_color="NA",cellwidth = 20, cellheight = 20, angle_col = 45,cluster_rows=TRUE,cluster_cols=TRUE, show_rownames = T, show_colnames = T, fontsize = 10)
```

```{r cossim dist hclust subset treatment}
csmap_dist_subset <- dist(1-csmap_subset) #make dist object using cs distance (1 - cs sim)

clust_csmap_dist_subset <- hclust(csmap_dist_subset)

plot(clust_csmap_dist_subset, hang = -1, cex = 1)
```

We can use these results to decide which (if any) putative signatures should be merged together before adding to the final list of signatures.

If we want to merge the entire group, we can use this chunk:

```{r merge whole treatment group}

sigMerge(tre_samples, )


```

